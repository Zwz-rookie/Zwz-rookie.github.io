<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux设备树</title>
      <link href="2021/040516115.html"/>
      <url>2021/040516115.html</url>
      
        <content type="html"><![CDATA[<p><font color=#999AAA >学习正点原子IMX6ULL嵌入式Linux驱动开发的笔记</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、设备树是什么"><a href="#一、设备树是什么" class="headerlink" title="一、设备树是什么"></a>一、设备树是什么</h1><p><font color=#999AAA >设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等<br><img src="https://img-blog.csdnimg.cn/20210328110223350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="设备树结构示意图"></p><h1 id="二、DTS、DTB-和-DTC"><a href="#二、DTS、DTB-和-DTC" class="headerlink" title="二、DTS、DTB 和 DTC"></a>二、DTS、DTB 和 DTC</h1><p>设备树源文件扩展名为.dts，DTS 是设备树源码文件；DTB 是将DTS 编译以后得到的二进制文件；DTC工具将.dts 编译为.dtb。<br><img src="https://img-blog.csdnimg.cn/20210328154535915.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="DTC、DTB、DTS关系"><br>dtc编译器可以把dts文件编译成为dtb，也可把dtb编译成为dts文件（本文只描述DTS到DTB的过程），编译命令格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtc [-<span class="type">I</span> <span class="type">input</span>-<span class="type">format</span>] [-<span class="type">O</span> <span class="type">output</span>-<span class="type">format</span>][-<span class="type">o</span> <span class="type">output</span>-<span class="type">filename</span>] [-<span class="type">V</span> <span class="type">output_version</span>] input_filename</span><br></pre></td></tr></table></figure><p>DTC 工具依赖于 dtc.c、flattree.c、fstree.c 等文件，最终编译并链接出 DTB 这个主机文件。如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行如下命令：<br>make all<br>或者：<br>make dtbs</p><h1 id="三、设备树在系统中的体现"><a href="#三、设备树在系统中的体现" class="headerlink" title="三、设备树在系统中的体现"></a>三、设备树在系统中的体现</h1><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的/proc/device-tree 目录下根据节点名字创建不同文件夹，如下图所示<br><img src="https://img-blog.csdnimg.cn/20210329094759272.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="设备树中各个节点的信息"><br>根节点属性属性表现为一个个的文件(图中细字体文件)，比如图中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件；<br>各个文件夹(途中粗字体文件夹)就是根节点“/”的各个子节点，比如“aliases”、“backlight”、“chosen”和“clocks”等等。<br><font color=#999AAA >/proc/device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入/proc/device-tree/soc 目录中就可以看到 soc 节点的所有子节点</p><h1 id="四、设备树节点解析流程"><a href="#四、设备树节点解析流程" class="headerlink" title="四、设备树节点解析流程"></a>四、设备树节点解析流程</h1><p>Linux内核解析DTB节点时，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。具体解析流程如下图：<br><img src="https://img-blog.csdnimg.cn/20210329100113784.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="设备树节点解析流程图"></p><h1 id="五、绑定信息文档"><a href="#五、绑定信息文档" class="headerlink" title="五、绑定信息文档"></a>五、绑定信息文档</h1><p>在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux 源码目录/Documentation/devicetree/bindings<br><img src="https://img-blog.csdnimg.cn/20210329101542439.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="设备树绑定文档"><br>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看Documentation/devicetree/bindings/i2c/i2c-imx.txt，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IMX6ULL的Linux系统移植</title>
      <link href="2021/031716114.html"/>
      <url>2021/031716114.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本博客是本人自己学习正点原子阿尔法开发板时本着好记性不如烂笔头的心情进行的笔记整理，所以会有不少内容与其教学资料相互重叠。如有侵权行为请立即联系我删除博客，感兴趣者可以百度左盟主开源的教学资料进行具体的学习。</p></blockquote><h1 id="系统镜像烧写"><a href="#系统镜像烧写" class="headerlink" title="系统镜像烧写"></a>系统镜像烧写</h1><h2 id="1-Windows下使用OTG烧写系统"><a href="#1-Windows下使用OTG烧写系统" class="headerlink" title="1. Windows下使用OTG烧写系统"></a>1. <strong>Windows下使用OTG烧写系统</strong></h2><p>使用NXP提供的mfgtool来向开发板烧写系统。先将开发板的USB_OTG口连接到电脑上。<br>        mfgtool先向板子上的DDR下载一个linux系统，然后用这个linux系统完成后面的烧写工作。<br>        烧写系用一般都是烧写到NAND或者EMMC里面的，也可以像裸机开发教程里那样子，烧写到SD卡里面。<br>        由于我使用的时EMMC8G的核心板，所以使用的.vbs文件选择：Mfgtool2-eMMC-ddr512-eMMC/SDcard。<br>        出现下图即为连接成功，点击Start可以往板子里烧写系统。<br>        <img src="https://img-blog.csdnimg.cn/20210311204007765.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="Mfgtool2-eMMC-ddr512-eMMC"><br>    烧写中……<br>        <img src="https://img-blog.csdnimg.cn/20210312142823857.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>   烧写过程中可以用串口工具接收返回的信息。如下图<br>        <img src="https://img-blog.csdnimg.cn/20210312142843808.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>    烧写完成后点击Stop，再点击Exit即可完成linux系统的烧写。<br>    <img src="https://img-blog.csdnimg.cn/2021031214301377.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>   <strong>注意：使用OTG烧写的时候要先把SD卡从板子上拔出来，等USB_OTG与电脑连接成功后就可以将SD卡插进去了。</strong></p><h2 id="2-Ubuntu下通过脚本烧写系统"><a href="#2-Ubuntu下通过脚本烧写系统" class="headerlink" title="2. Ubuntu下通过脚本烧写系统"></a>2. <strong>Ubuntu下通过脚本烧写系统</strong></h2><h3 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a><strong>整体流程：</strong></h3><pre><code>     1.烧写Linux系统到SD卡。     2.设置SD启动，进入Linux系统。     3.利用串口发送指令，在SD卡的系统下将Linux系统烧写到EMMC或者NAND里。     4.设置EMMC或者NAND启动，进入系统。     </code></pre><h3 id="烧写系统到SD卡："><a href="#烧写系统到SD卡：" class="headerlink" title="烧写系统到SD卡："></a><strong>烧写系统到SD卡：</strong></h3><p> 将路径mfgtool-&gt;Profiles-&gt;Linux-&gt;OS Firmware-&gt;files的files文件夹拷贝到linux系统目录下。<br> 修改files文件夹下imx6mksdboot.sh的权限：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">777</span> imx6mksdboot.sh</span><br></pre></td></tr></table></figure><p> 查看imx6mksdboot.sh的参数说明：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./imx6mksdboot.sh -<span class="literal">-help</span></span><br></pre></td></tr></table></figure><p> 根据参数说明，烧写系统到SD卡中：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./imx6mksdboot.sh <span class="literal">-device</span> /dev/sdb <span class="literal">-flash</span> emmc <span class="literal">-ddrsize</span> <span class="number">512</span></span><br></pre></td></tr></table></figure><h3 id="烧写系统到EMMC："><a href="#烧写系统到EMMC：" class="headerlink" title="烧写系统到EMMC："></a><strong>烧写系统到EMMC：</strong></h3><p> 这个步骤个人理解际上与烧写到SD卡上的步骤完全一致。无非就是烧写到SD卡上的时候SD卡挂载在计算机的linux系统中，而进行EMMC烧写的系统时候，EMMC挂载在开发板的lInux中。因此进行EMMC的烧写也就是重复SD卡烧写的过程，所以要求开发板的存储介质中有Mfgtool的files文件夹。故：<br>     1、先将files文件夹拷贝到SD卡的Linux系统文件目录下，我拷贝到了/home/root目录。（由于linux隔一段时间会将缓存中的文件同步到移动设备中，但是时间间隔不确定，建议手动执行sync命令进行同步以确保文件传输完成）<br>     2、修改EMMC固化脚本权限：<strong>chmod +x imx6mkemmcboot.sh</strong><br>     <img src="https://img-blog.csdnimg.cn/20210312235452682.PNG#pic_center" alt="在这里插入图片描述"><br>     3、查看脚本说明：**./imx6mkemmcboot.sh –help**<br>     <img src="https://img-blog.csdnimg.cn/20210312235234372.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>     4、查看emmc挂载节点：<strong>fdisk -l</strong><br>     <img src="https://img-blog.csdnimg.cn/20210312235249297.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>     5、根据脚本说明和挂载节点输入命令进行系统烧写：**./imx6mkemmcboot.sh -device /dev/mmcblk1 -ddrsize 512**<br>     <img src="https://img-blog.csdnimg.cn/2021031223571113.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X0RpYW1vbmRf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>    由于此次往EMMC固化系统是由IMX6ULL进行的，所以烧写的速度没有由PC进行迅速，需要较长等待时间</p><h3 id="烧写系统到NAND："><a href="#烧写系统到NAND：" class="headerlink" title="烧写系统到NAND："></a><strong>烧写系统到NAND：</strong></h3><p> 过程参考步骤<strong>烧写系统到EMMC</strong>即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UBOOT</title>
      <link href="2021/031716109.html"/>
      <url>2021/031716109.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本博客是本人自己学习正点原子阿尔法开发板时本着好记性不如烂笔头的心情进行的笔记整理，所以会有不少内容与其教学资料相互重叠。如有侵权行为请立即联系我删除博客，感兴趣者可以百度左盟主开源的教学资料进行具体的学习。</p></blockquote><h2 id="一、何为uboot"><a href="#一、何为uboot" class="headerlink" title="一、何为uboot?"></a>一、何为uboot?</h2><p><strong>Uboot的作用就如同电脑开机时进入BIOS界面一样，起到的是引导系统启动的作用，同时也可以利用Uboot进行系统固件的刷新，升级API。</strong></p><ol><li><p>uboot是一个裸机程序,比较复杂。</p></li><li><p>uboot,就是一个bootloader，作用就是用于启动Linux或其他系统。<br>Uboot最主要的工作就是初始化DDR。因为Linux是运行在DDR里面的。一般Linux镜像zlmage(ulmage)+设备树(.dtb)存放在SD、EMMC、NAND、SPI FLASH等等外置存储区域。<br>这里就牵扯到一个问题，需要将Linux镜像从外置flash拷贝到DDR中，再去启动。<strong>Uboot的主要目的就是为系统的启动做准备。</strong><br>Uboot,不仅仅能启动Linux，也可以启动其他系统,比如vxworkS.。Linux不仅仅能通过uboot启动。<br>uboot,是个通用的bootloader，他支持多种架构。</p></li><li><p>Uboot获取：<br>1、首先就是uboot官网。缺点就是支持少，比如某一款具体芯片驱动等不完善。<br><a href="http://www.denx.de/wiki/U-Boot/">uboot 官网</a></p></li><li><p>SOC 厂商会从 uboot官网下载某一个版本的uboot，然后在这个版本的uboot上加入相应的SOC 以及驱动。这就是SOC 厂商定制版的uboot。NXP官方的I.MX6ULL EVK板子。<br><a href="http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tag/?h=imx_v2016.03_4.1.15_2.0.0_ga&id=%20rel_imx_4.1.15_2.1.0_ga">NXP维护的uboot</a><br>3、做开发板的厂商，开发板会参考SOC厂商的板子。开发板必然会和官方的板子不一样。因此开发板厂商又会去修改SOC 厂商做好的uboot，以适应自己的板子。</p></li></ol><h2 id="二、U-Boot初次编译"><a href="#二、U-Boot初次编译" class="headerlink" title="二、U-Boot初次编译"></a>二、U-Boot初次编译</h2><p><strong>整体流程：</strong></p><ol><li>安装 ncurses 库<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install libncurses5<span class="literal">-dev</span></span><br></pre></td></tr></table></figure></li><li>解压uboot源码<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar <span class="literal">-vxjf</span> uboot<span class="literal">-imx</span><span class="literal">-2016</span>.<span class="number">03</span><span class="literal">-2</span>.<span class="number">1.0</span><span class="literal">-g4475ea1</span><span class="literal">-v1</span>.<span class="number">3</span>.tar.bz2</span><br></pre></td></tr></table></figure></li><li>清除工程<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- distclean</span><br></pre></td></tr></table></figure></li><li>配置uboot<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- mx6ull_14x14_ddr512_emmc_defconfig</span><br></pre></td></tr></table></figure></li><li>编译uboot内核<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=<span class="number">1</span> ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- <span class="literal">-j12</span></span><br></pre></td></tr></table></figure>V=1打印编译过程;<br>-j12:使用 12 核来编译 uboot;</li></ol><p><strong>过程优化：</strong><br>1、编译UBOOT的时候需要先配置<br>2、编译完成以后就会生成一个u-boot.bin。必须向u-boot.bin添加头部信息。Uboot编译最后会通过/tools/mkimage 软件添加头部信息，生成u-boot.imx。<br>3、如果配置过uboot，那么一定要注意shell脚本会清除整个工程，那么配置的文件也会被删除，配置项也会被删除掉。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- mx6ull_14x14_ddr256_nand_defconfig</span><br><span class="line">make V=<span class="number">1</span> ARCH=arm CROSS_COMPILE=arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>- <span class="literal">-j4</span></span><br></pre></td></tr></table></figure><p>4.为了方便开发.建议直接在uboot顶层Makefile里面设置好ARCH 和CORSS_COMPILE这两个变量的值。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set default to nothing for native builds</span></span><br><span class="line">ifeq (<span class="variable">$</span>(HOSTARCH),<span class="variable">$</span>(ARCH))</span><br><span class="line">CROSS_COMPILE ?=</span><br><span class="line">endif</span><br><span class="line">  </span><br><span class="line">ARCH ?= arm</span><br><span class="line">CROSS_COMPILE ?= arm<span class="literal">-linux</span><span class="literal">-gnueabihf</span>-</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux启用TFTP服务</title>
      <link href="2021/031716111.html"/>
      <url>2021/031716111.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、安装-tftp-hpa-和-tftpd-hpa"><a href="#1、安装-tftp-hpa-和-tftpd-hpa" class="headerlink" title="1、安装 tftp-hpa 和 tftpd-hpa"></a>1、安装 tftp-hpa 和 tftpd-hpa</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install tftp<span class="literal">-hpa</span> tftpd<span class="literal">-hpa</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install xinetd</span><br></pre></td></tr></table></figure><p>创建存放的服务器内容的文件夹并给予权限</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/zwz/linux/tftpboot</span><br><span class="line">chmod <span class="number">777</span> /home/zwz/linux/tftpboot</span><br></pre></td></tr></table></figure><p>记住这个文件夹路径，后续多次使用。</p><h1 id="2、配置TFTP"><a href="#2、配置TFTP" class="headerlink" title="2、配置TFTP"></a>2、配置TFTP</h1><p>进入配置文件夹</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/xinetd.d</span><br></pre></td></tr></table></figure><p>创建tftp文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim tftp</span><br></pre></td></tr></table></figure><p>tftp配置内容如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server tftp</span><br><span class="line">&#123;</span><br><span class="line">    socket_type  = dgram</span><br><span class="line">    protocol     = udp</span><br><span class="line">    wait         = yes</span><br><span class="line">    user         = root</span><br><span class="line">    server       = /usr/sbin/in.tftpd</span><br><span class="line">    server_args  = <span class="literal">-s</span> /home/zwz/linux/tftpboot/</span><br><span class="line">    disable      = no</span><br><span class="line">    per_source   = <span class="number">11</span></span><br><span class="line">    cps          = <span class="number">100</span> <span class="number">2</span></span><br><span class="line">    flags        = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动TFTP服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd<span class="literal">-hpa</span> <span class="built_in">start</span></span><br></pre></td></tr></table></figure><p>打开/etc/default/tftpd-hpa，修改服务器文件夹位置与前面创建的文件夹一致。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/default/tftpd-hpa</span></span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=<span class="string">&quot;tftp&quot;</span></span><br><span class="line">TFTP_DIRECTORY=<span class="string">&quot;/home/zwz/linux/tftpboot&quot;</span></span><br><span class="line">TFTP_ADDRESS=<span class="string">&quot;:69&quot;</span></span><br><span class="line">TFTP_OPTIONS=<span class="string">&quot;-l -c -s&quot;</span></span><br></pre></td></tr></table></figure><h1 id="3、重启TFTP服务器"><a href="#3、重启TFTP服务器" class="headerlink" title="3、重启TFTP服务器"></a>3、重启TFTP服务器</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd<span class="literal">-hpa</span> restart</span><br></pre></td></tr></table></figure><h1 id="4、实践验证"><a href="#4、实践验证" class="headerlink" title="4、实践验证"></a>4、实践验证</h1><p>1、拷贝文件到tftpboot文件夹（例如zImage）<br>2、给镜像权限chmod 777 zImage<br>3、客户端使用对应的tftp命令尝试即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo解决中文乱码问题</title>
      <link href="2021/031616108.html"/>
      <url>2021/031616108.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h2><p>由于站点配置文件没有使用utf-8编码而导致的中文乱码。</p><h2 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h2><p>将title改为中文字符，language: zh-CN。<br>将站点配置文件_config.yml保存成utf-8格式。<br>重启博客 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code><br>登录本地网站即可查看是否配置成功。</p><h1 id="2、博客内容中文乱码"><a href="#2、博客内容中文乱码" class="headerlink" title="2、博客内容中文乱码"></a>2、博客内容中文乱码</h1><h2 id="1、原因-1"><a href="#1、原因-1" class="headerlink" title="1、原因"></a>1、原因</h2><p>markdown文件没有用utf-8编码保存。</p><h2 id="2、解决方法-1"><a href="#2、解决方法-1" class="headerlink" title="2、解决方法"></a>2、解决方法</h2><p>使用记事本打开博客文件，不需要修改，保存的时候以utf-8的格式保存。<br>注意保存的时候不要修改后缀，默认会改成txt文件，注意保存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux启用NFS服务</title>
      <link href="2021/031616110.html"/>
      <url>2021/031616110.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装NFS服务"><a href="#一、安装NFS服务" class="headerlink" title="一、安装NFS服务"></a>一、安装NFS服务</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install nfs<span class="literal">-kernel</span><span class="literal">-server</span> rpcbind</span><br></pre></td></tr></table></figure><p>（顺便可以开启SSH服务<strong>sudo apt-get install openssh-server</strong>）</p><h1 id="二、配置NFS文件"><a href="#二、配置NFS文件" class="headerlink" title="二、配置NFS文件"></a>二、配置NFS文件</h1><p>打开配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure><p>添加服务器文件夹路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/zwz/linux/nfs *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>如上，我的路径为/home/zwz/linux/nfs</p><h1 id="三、重启NFS服务"><a href="#三、重启NFS服务" class="headerlink" title="三、重启NFS服务"></a>三、重启NFS服务</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nfs<span class="literal">-kernel</span><span class="literal">-server</span> restart</span><br></pre></td></tr></table></figure><h1 id="四、实验测试"><a href="#四、实验测试" class="headerlink" title="四、实验测试"></a>四、实验测试</h1><p>1、拷贝文件到nfs文件夹（例如zImage）<br>2、客户端使用对应的NFS命令尝试即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式常用功能模块原理简述</title>
      <link href="2021/030816113.html"/>
      <url>2021/030816113.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-GPIO"><a href="#1-GPIO" class="headerlink" title="1. GPIO"></a>1. GPIO</h2><p>分为GPI（输入模式）和GPO（输出模式）。其中，GPI可根据单片机内部电路配置上拉电阻等，具体需要视单片机而定，GPO分为几种不同的输出模式，如开漏、推挽等输出模式，配合外部的电平转换电路和隔离电路，常做开关量。<br>此功能常用的寄存器一般包括方向寄存器和数据寄存器。方向寄存器控制GPO/GPI。而数据寄存器控制IO电平状态。此外还有控制驱动能力等的寄存器，视实际运用场合进行配置。</p><h2 id="2-ADC"><a href="#2-ADC" class="headerlink" title="2. ADC"></a>2. ADC</h2><p> 进行模拟量/数字量转换的模块。一般多通道共享一个AD转换器，因此常常搭配采样保持器使用。当然，这不是软件设计者考虑的东西。ADC转换功能需要选择ADC时钟，时钟与寄存器中决定分频系数的位共同决定采样频率。根据实际需要常常采用用所需的采样频率反求ADC时钟的分频系数的方法。ADC采样有硬件触发和软件触发的方式：硬件触发采用的是硬件定时进行采样，而软件触发是通过向相应寄存器写位进行触发。ADC还带有比较功能，用来筛选一些无效的数据，此外还有连续转换、设定长采样时间等功能，这些也在相应寄存器里进行配置。</p><h2 id="3-定时中断"><a href="#3-定时中断" class="headerlink" title="3. 定时中断"></a>3. 定时中断</h2><p>定时中断是基于单片机内部计数器实现的。通过对内部计数器的时钟源和分频系数的选择，可以确定一个时钟脉冲所占的实际时间的大小，因此，通过<strong>设置模数寄存器即可调节定时时间</strong>，再<strong>使能计数器（此处应认为定时器）溢出中断</strong>，当<strong>数值寄存器</strong>达到模数寄存器的值的时候，<strong>产生溢出中断信号</strong>，即可进入定时中断服务函数。<br><strong>中断服务函数需要进行标志位清除</strong>。否则会导致中断不断被触发，PC指针一直在中断服务函数里，一直执行中断服务函数，不运行其他程序的内容。</p><h2 id="4-外部中断"><a href="#4-外部中断" class="headerlink" title="4. 外部中断"></a>4. 外部中断</h2><p> 外部IO中断。中断信号由外部设备上报，MCU接收中断信号，进入中断服务函数。由于是接收外部中断信号，所以需要复用对应的IO为输入模式，设置中断信号（沿/电平），设定中断优先级（有些单片机默认），使能IO中断，编写中断服务函数。（注意各个模块的中断向量表编号是固定的，编写服务函数的时候通过这个编号绑定中断服务函数）中断服务函数里需要清除中断标志位以让PC返回，中断函数不能是个死循环。</p><h2 id="5-PWM（脉冲宽度调制）"><a href="#5-PWM（脉冲宽度调制）" class="headerlink" title="5. PWM（脉冲宽度调制）"></a>5. PWM（脉冲宽度调制）</h2><p> PWM的实现原理:模数寄存器+计数器+通道数值寄存器。<br> <strong>脉冲周期</strong>：此周期的数值反应为模数寄存器的值。PWM需要配置时钟源。根据时钟源和自己所需要的脉冲周期，可以确定模数寄存器的数值。简单地形容一下公式：模数寄存器的值=目标周期/（1/时钟源频率）。<br> <strong>占空比</strong>：占空比的形式分为三种，中间对齐和两端对齐的方式，这里选取最常用的左端对齐方式。占空比可理解为为一个脉冲周期里高电平所占有的比例。假设脉冲周期1S，40%占空比则意味着高电平时间0.4s。因此，占空比的数值表示为通道数值寄存器的值。简单地形容一下公式：通道数值寄存器的值=占空比X模数寄存器的值=占空比X目标周期/（1/时钟源频率）</p><h2 id="6-DMA"><a href="#6-DMA" class="headerlink" title="6. DMA"></a>6. DMA</h2><p> 直接存储器访问。高效的批量数据传输功能，省去了CPU读取翻译指令的时间，会占用总线。分请求、响应、传输、结束四个步骤。DMA获得总线控制权后，CPU即刻挂起或者只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与IO口进行DMA传输。传输的两个重要参数：数据的起始位置、数据长度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接和释放机制</title>
      <link href="2021/030816112.html"/>
      <url>2021/030816112.html</url>
      
        <content type="html"><![CDATA[<h2 id="连接：三次握手"><a href="#连接：三次握手" class="headerlink" title="连接：三次握手"></a>连接：三次握手</h2><p>三次握手的原因：<br>TCP 是全双工通信，任何一方都可以发起建立连接的请求，假设 A 是客户端，B 是服务器。</p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。<br>三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h2 id="释放：四次挥手"><a href="#释放：四次挥手" class="headerlink" title="释放：四次挥手"></a>释放：四次挥手</h2><p>四次挥手的原因：</p><ol><li>为了保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文能被 B 接收，如果该报文丢失，B 没有收到就会超时重传之前的FIN+ACK 报文，而如果 A 在发送确认报文后就立即释放连接就无法收到 B 超时重传的报文，因而也不会再一次发送确认报文段，B 就无法正常进入 CLOSED 状态。</li><li>2MSL 时间之后，本连接中的所有报文就都会从网络中消失，可以防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</li></ol><p>补充：<br>TCP 还设有一个保活计时器，用于解决客户端主机故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为 2 小时。如果 2 小时内没有收到就间隔 75 秒发送一次探测报文，连续 10 次都没有响应后就关闭连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/022216107.html"/>
      <url>2021/022216107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
